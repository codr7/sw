C P S / L R

* add , to eval top of stack

* add do
** consume until ; or end
** write body
** emit call

* add Expr form
** (...)
** begin/endPackage like []
** emit items

(foo:42; foo)
42 check

* more macros
** LC
** RC
** PC
** PS
** SC
** SP

fib: do C 1 > if dec C fib S else dec fib +;
1000 (20 fib P) benchmark say

fib: do
  RC 1 > if
    dec LC L + fib return
  else
    1 = if S;
  P;

* add load macro


func permutations<T>(_ values: [T], _ current: [T], _ idx: Int, _ result: inout [[T]]) {
    result.append(current)
    if idx == current.count { return }
    
    for v in values[1...] {
        for i in idx..<current.count {
            var c = current
            let pv = c[i]
            c[i] = v
            permutations(values, c, idx + 1, &result)
            c[i] = pv
        }
    }    
}

func permutations<T>(_ values: [T], _ n: Int) -> [[T]] {
    let current = Array(repeating: values[0], count: n)
    var result: [[T]] = []
    permutations(values, current, 0, &result)
    return result
}
